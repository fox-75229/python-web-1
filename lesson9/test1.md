# 程式碼運作詳解：Async/Await 與 Try...Catch

你好！很高興能協助你理解這段程式碼。

這段程式碼完美地展示了 JavaScript 中 `async/await` 如何處理「非同步」 (asynchronous) 操作，以及 `try...catch` 如何捕捉這些操作中可能發生的錯誤。

這是一個很棒的例子！我們一步一步來看它是如何運作的。

---

### 程式碼的逐步執行順序

你的程式碼執行順序並不是「由上到下」一行一行跑完，因為 `async` 函式的關係。

它會像這樣跳著執行：

**階段一：主程式的「同步」執行**

1.  **定義函式：** 瀏覽器讀取程式碼，首先會定義 `mockFetch` 函式和 `getMyData` 函式，把們準備好。
2.  **印出 A：** 程式碼往下執行到 `console.log("A. 準備呼叫 getMyData()...")`。
    * **主控台輸出 (第1行)：** `A. 準備呼叫 getMyData()...`
3.  **呼叫 `getMyData`：** 接著，`getMyData()` 函式被呼叫並開始執行。

**階段二：進入 `getMyData` 函式 (第一次執行)**

4.  **印出 1：** `getMyData` 函式內的第一行 `console.log("1. 函式開始執行，準備 'try'...")` 執行。
    * **主控台輸出 (第2行)：** `1. 函式開始執行，準備 'try'...`
5.  **呼叫 `mockFetch`：** 程式碼進入 `try` 區塊，準備執行 `await mockFetch(false)`。它首先呼叫 `mockFetch(false)`。
6.  **`mockFetch` 內部：**
    * `mockFetch` 開始執行。
    * `console.log("店員：開始去後台拿資料...")` 被執行。
        * **主控台輸出 (第3行)：** `店員：開始去後台拿資料...`
    * `mockFetch` 建立了一個 `Promise` (承諾)。
    * 它啟動了一個 `setTimeout` 計時器，設定為 2 秒後執行。
    * **重點：** `mockFetch` 函式 *立刻* 返回 (return) 這個「還在等待中」(pending) 的 `Promise`。它不會等到 2 秒後才返回。

**階段三：`await` 暫停與主程式繼續**

7.  **`await` 登場：** `getMyData` 函式中的 `await` 關鍵字拿到了 `mockFetch` 回傳的「等待中」 Promise。
8.  **暫停 `getMyData`：** `await` 的作用就是：「OK，這個 Promise 還沒完成，我 (getMyData 函式) 就在這裡暫停，*讓出執行權*，等 2 秒後這個 Promise 有結果了 (無論成功或失敗) 我再回來繼續。」
9.  **主程式繼續：** 因為 `getMyData` 函式被「暫停」了，JavaScript 會回到呼叫 `getMyData()` 的地方 (也就是步驟 3)，然後繼續往下執行主程式。
10. **印出 B：** 執行 `console.log("B. 程式碼繼續往下跑... (不會等 getMyData 完成)")`。
    * **主控台輸出 (第4行)：** `B. 程式碼繼續往下跑... (不會等 getMyData 完成)`
11. **主程式結束：** 主程式的同步部分到此全部執行完畢。瀏覽器現在處於空閒狀態，等待事件發生（例如那 2 秒鐘的計時器）。

**階段四：2 秒鐘後... (非同步事件發生)**

12. **計時器觸發：** 2 秒鐘到了，`setTimeout` 的回呼函式 (callback) 被觸發。
13. **Promise 失敗：** 在回呼函式中，`isSuccess` 是 `false`，所以 `else` 區塊被執行。
14. **`reject` 被呼叫：** `reject("錯誤：伺服器 500 (壞掉了)")` 被執行。這使得 `mockFetch` 返回的那個 `Promise` 狀態從「等待中」(pending) 變為「已拒絕」(rejected)，並帶有錯誤訊息。

**階段五：`getMyData` 函式被喚醒**

15. **`await` 收到結果：** 之前在「等待」的 `await` 關鍵字收到了這個「已拒絕」的狀態。
16. **`await` 拋出錯誤：** 因為 `await` 收到的是 `reject` (失敗)，它會立刻「拋出」(throw) 這個錯誤，錯誤內容就是 `reject` 裡的訊息。
17. **`try...catch` 捕捉：** `try` 區塊內的程式碼 (`let data = ...`) 因為拋出了錯誤而中斷。執行流程 *立刻跳到* `catch (error)` 區塊。
18. **`error` 變數：** `error` 變數現在的值就是 `"錯誤：伺服器 500 (壞掉了)"`。
19. **印出 3 (失敗)：** `catch` 區塊內的 `console.log("3. (2秒後) 失敗了... 原因是：", error)` 被執行。
    * **主控台輸出 (第5行)：** `3. (2秒後) 失敗了... 原因是： 錯誤：伺服器 500 (壞掉了)`
    * (注意：`try` 區塊中 `console.log("3. (2秒後) 成功了！...")` 這行 *永遠不會* 被執行到，因為錯誤在它之前就發生了。)

**階段六：`getMyData` 函式結束**

20. **`catch` 結束：** `catch` 區塊執行完畢。
21. **印出 4：** 程式碼繼續往下執行 `try...catch` 結構 *之後* 的 `console.log("4. 函式執行完畢。")`。
    * **主控台輸出 (第6行)：** `4. 函式執行完畢。`
22. **`getMyData` 結束：** `getMyData` 函式到此全部執行完畢。

---

### 最終的主控台輸出順序

綜合以上步驟，你會在主控台 (Console) 看到以下依序出現的訊息：